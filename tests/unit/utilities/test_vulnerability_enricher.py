"""
Test suite for vulnerability enrichment utilities.

This module contains comprehensive tests for the vulnerability enricher functionality
including external API integration for EPSS scores, CISA KEV data, and NVD details.
"""

import pytest
import json
import time
import os
from unittest.mock import patch, Mock
from typing import Dict, List, Any

from src.workbench_cli.utilities.vuln_report.cve_data_gathering import (
    enrich_vulnerabilities,
    _fetch_external_vulnerability_data,
    _fetch_epss_scores,
    _fetch_cisa_kev_data,
    _fetch_nvd_data,
    _fetch_single_cve_nvd,
    _parse_nvd_vulnerability,
    RateLimiter
)


class TestVulnerabilityEnricher:
    """Test cases for main vulnerability enrichment functionality."""

    def test_enrich_vulnerabilities_empty_list(self):
        """Test enrichment with empty CVE list."""
        result = enrich_vulnerabilities([])
        assert result == {}

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_external_vulnerability_data')
    def test_enrich_vulnerabilities_with_cves(self, mock_fetch):
        """Test enrichment with CVE list."""
        mock_fetch.return_value = {
            "CVE-2022-12345": {
                "epss_score": 0.85,
                "cisa_kev": True
            }
        }
        
        result = enrich_vulnerabilities(["CVE-2022-12345"])
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        mock_fetch.assert_called_once()

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_epss_scores')
    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_cisa_kev_data')
    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_nvd_data')
    def test_fetch_external_vulnerability_data_all_sources(self, mock_nvd, mock_kev, mock_epss):
        """Test fetching from all external data sources."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.return_value = {
            "CVE-2022-12345": {"epss_score": 0.85, "epss_percentile": 0.95}
        }
        mock_kev.return_value = ["CVE-2022-12345"]
        mock_nvd.return_value = {
            "CVE-2022-12345": {"nvd_description": "Test description"}
        }
        
        result = _fetch_external_vulnerability_data(cve_list)
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        assert result["CVE-2022-12345"]["cisa_kev"] == True
        assert result["CVE-2022-12345"]["nvd_description"] == "Test description"

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_epss_scores')
    def test_fetch_external_vulnerability_data_epss_only(self, mock_epss):
        """Test fetching EPSS data only."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.return_value = {
            "CVE-2022-12345": {"epss_score": 0.75}
        }
        
        result = _fetch_external_vulnerability_data(
            cve_list, 
            nvd_enrichment=False,
            epss_enrichment=True,
            cisa_kev_enrichment=False
        )
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.75
        assert result["CVE-2022-12345"]["cisa_kev"] == False
        assert result["CVE-2022-12345"]["nvd_description"] is None

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_epss_scores')
    def test_fetch_external_vulnerability_data_with_exceptions(self, mock_epss):
        """Test handling of exceptions during external data fetching."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.side_effect = Exception("EPSS API failed")
        
        # Should not raise exception, should return initialized data structure
        result = _fetch_external_vulnerability_data(cve_list)
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] is None
        assert result["CVE-2022-12345"]["cisa_kev"] == False


class TestEpssDataFetching:
    """Test cases for EPSS score fetching."""

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_epss_scores_success(self, mock_get):
        """Test successful EPSS score fetching."""
        mock_response = {
            "status": "OK",
            "data": [
                {
                    "cve": "CVE-2022-12345",
                    "epss": "0.85000",
                    "percentile": "0.95000"
                },
                {
                    "cve": "CVE-2022-67890",
                    "epss": "0.15000",
                    "percentile": "0.25000"
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_epss_scores(["CVE-2022-12345", "CVE-2022-67890"])
        
        assert len(result) == 2
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        assert result["CVE-2022-12345"]["epss_percentile"] == 0.95
        assert result["CVE-2022-67890"]["epss_score"] == 0.15

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_epss_scores_batch_processing(self, mock_get):
        """Test EPSS batch processing with large CVE lists."""
        # Create a list larger than batch size (100)
        cve_list = [f"CVE-2022-{i:05d}" for i in range(150)]
        
        # Mock responses for two batches
        mock_response = {
            "status": "OK",
            "data": [{"cve": cve, "epss": "0.5", "percentile": "0.5"} for cve in cve_list[:100]]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        with patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.time.sleep'):
            result = _fetch_epss_scores(cve_list)
        
        # Should be called twice for two batches
        assert mock_get.call_count == 2
        assert len(result) == 100  # Only first batch in mock response

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_epss_scores_api_error(self, mock_get):
        """Test handling of EPSS API errors."""
        mock_get.side_effect = Exception("API Error")
        
        result = _fetch_epss_scores(["CVE-2022-12345"])
        
        assert result == {}

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_epss_scores_invalid_response(self, mock_get):
        """Test handling of invalid EPSS API response."""
        mock_response = {"status": "ERROR", "message": "Invalid request"}
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_epss_scores(["CVE-2022-12345"])
        
        assert result == {}


class TestCisaKevDataFetching:
    """Test cases for CISA KEV data fetching."""

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_cisa_kev_data_success(self, mock_get):
        """Test successful CISA KEV data fetching."""
        mock_response = {
            "vulnerabilities": [
                {
                    "cveID": "CVE-2022-12345",
                    "vendorProject": "Test Vendor",
                    "product": "Test Product"
                },
                {
                    "cveID": "CVE-2022-67890",
                    "vendorProject": "Another Vendor",
                    "product": "Another Product"
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345", "CVE-2022-99999"])
        
        assert len(result) == 1
        assert "CVE-2022-12345" in result
        assert "CVE-2022-99999" not in result

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_cisa_kev_data_no_vulnerabilities(self, mock_get):
        """Test CISA KEV response with no vulnerabilities section."""
        mock_response = {"other_data": "value"}
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345"])
        
        assert result == []

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_cisa_kev_data_api_error(self, mock_get):
        """Test handling of CISA KEV API errors."""
        mock_get.side_effect = Exception("API Error")
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345"])
        
        assert result == []


class TestNvdDataFetching:
    """Test cases for NVD data fetching."""

    def test_fetch_nvd_data_caching(self):
        """Test that NVD data is cached between calls."""
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import _NVD_CACHE
        
        # Clear cache
        _NVD_CACHE.clear()
        
        with patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering._fetch_single_cve_nvd') as mock_fetch:
            mock_fetch.return_value = {"nvd_description": "Test desc"}
            
            # First call should fetch from API
            result1 = _fetch_nvd_data(["CVE-2022-12345"])
            assert mock_fetch.call_count == 1
            
            # Second call should use cache
            result2 = _fetch_nvd_data(["CVE-2022-12345"])
            assert mock_fetch.call_count == 1  # Should not increase
            
            assert result1 == result2

    @patch.dict(os.environ, {"NVD_API_KEY": "test-key"})
    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.ThreadPoolExecutor')
    def test_fetch_nvd_data_with_api_key(self, mock_executor):
        """Test NVD data fetching with API key."""
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import _NVD_CACHE
        
        _NVD_CACHE.clear()
        
        # Mock executor behavior
        mock_future = Mock()
        mock_future.result.return_value = {"nvd_description": "Test desc"}
        mock_executor.return_value.__enter__.return_value.submit.return_value = mock_future
        
        with patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.as_completed') as mock_as_completed:
            mock_as_completed.return_value = [mock_future]
            
            result = _fetch_nvd_data(["CVE-2022-12345"])
            
            # Should use higher concurrency with API key
            mock_executor.assert_called_with(max_workers=5)
            assert "CVE-2022-12345" in result

    @patch.dict(os.environ, {}, clear=True)
    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.ThreadPoolExecutor')
    def test_fetch_nvd_data_without_api_key(self, mock_executor):
        """Test NVD data fetching without API key."""
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import _NVD_CACHE
        
        _NVD_CACHE.clear()
        
        # Mock executor behavior
        mock_future = Mock()
        mock_future.result.return_value = {"nvd_description": "Test desc"}
        mock_executor.return_value.__enter__.return_value.submit.return_value = mock_future
        
        with patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.as_completed') as mock_as_completed:
            mock_as_completed.return_value = [mock_future]
            
            result = _fetch_nvd_data(["CVE-2022-12345"])
            
            # Should use lower concurrency without API key
            mock_executor.assert_called_with(max_workers=2)
            assert "CVE-2022-12345" in result

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_single_cve_nvd_success(self, mock_get):
        """Test successful single CVE fetching from NVD."""
        mock_response = {
            "vulnerabilities": [
                {
                    "cve": {
                        "descriptions": [
                            {
                                "lang": "en",
                                "value": "Test vulnerability description"
                            }
                        ],
                        "weaknesses": [
                            {
                                "type": "Primary",
                                "description": [
                                    {
                                        "lang": "en",
                                        "value": "CWE-79"
                                    }
                                ]
                            }
                        ],
                        "references": [
                            {
                                "url": "https://example.com/vuln",
                                "source": "test"
                            }
                        ],
                        "metrics": {
                            "cvssMetricV31": [
                                {
                                    "cvssData": {
                                        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                                        "baseScore": 6.1
                                    }
                                }
                            ]
                        }
                    }
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import RateLimiter
        rate_limiter = RateLimiter(max_workers=1, delay=0.1)
        
        result = _fetch_single_cve_nvd("CVE-2022-12345", None, rate_limiter, 30)
        
        assert result["nvd_description"] == "Test vulnerability description"
        assert result["nvd_cwe"] == ["CWE-79"]
        assert result["full_cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
        assert result["cvss_score"] == 6.1

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_single_cve_nvd_rate_limited(self, mock_get):
        """Test handling of rate limiting in NVD API."""
        # First call returns 429, second call succeeds
        mock_response_429 = Mock()
        mock_response_429.status_code = 429
        mock_response_429.headers = {"Retry-After": "1"}
        
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.raise_for_status.return_value = None
        mock_response_success.json.return_value = {
            "vulnerabilities": [
                {
                    "cve": {
                        "descriptions": [
                            {
                                "lang": "en",
                                "value": "Test description"
                            }
                        ]
                    }
                }
            ]
        }
        
        mock_get.side_effect = [mock_response_429, mock_response_success]
        
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import RateLimiter
        rate_limiter = RateLimiter(max_workers=1, delay=0.1)
        
        with patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.time.sleep') as mock_sleep:
            result = _fetch_single_cve_nvd("CVE-2022-12345", None, rate_limiter, 30)
        
        assert result["nvd_description"] == "Test description"
        assert mock_get.call_count == 2
        # Should have slept due to rate limiting (may be called multiple times due to rate limiter)
        assert mock_sleep.call_count >= 1
        # One of the calls should be for the retry-after delay
        sleep_calls = [call.args[0] for call in mock_sleep.call_args_list]
        assert 1 in sleep_calls

    @patch('src.workbench_cli.utilities.vuln_report.cve_data_gathering.requests.get')
    def test_fetch_single_cve_nvd_with_api_key(self, mock_get):
        """Test single CVE fetching with API key."""
        mock_response = {
            "vulnerabilities": [
                {
                    "cve": {
                        "descriptions": [
                            {
                                "lang": "en",
                                "value": "Test vulnerability with API key"
                            }
                        ]
                    }
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        from src.workbench_cli.utilities.vuln_report.cve_data_gathering import RateLimiter
        rate_limiter = RateLimiter(max_workers=1, delay=0.1)
        
        result = _fetch_single_cve_nvd("CVE-2022-12345", "test-api-key", rate_limiter, 30)
        
        # Check that API key was included in headers
        call_args = mock_get.call_args
        assert "apiKey" in call_args[1]["headers"]
        assert call_args[1]["headers"]["apiKey"] == "test-api-key"
        assert result["nvd_description"] == "Test vulnerability with API key"

    def test_parse_nvd_vulnerability_complete_data(self):
        """Test parsing of complete NVD vulnerability data."""
        nvd_data = {
            "descriptions": [
                {
                    "lang": "en",
                    "value": "Critical vulnerability in test component"
                }
            ],
            "weaknesses": [
                {
                    "type": "Primary",
                    "description": [
                        {
                            "lang": "en",
                            "value": "CWE-79"
                        }
                    ]
                },
                {
                    "type": "Secondary",
                    "description": [{"lang": "en", "value": "CWE-20"}]
                }
            ],
            "references": [
                {"url": "https://example.com/ref1", "source": "vendor", "tags": ["Vendor Advisory"]},
                {"url": "https://example.com/ref2", "source": "mitre", "tags": ["Third Party Advisory"]}
            ],
            "metrics": {
                "cvssMetricV31": [{
                    "cvssData": {
                        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                        "baseScore": 6.1
                    }
                }]
            }
        }
        
        result = _parse_nvd_vulnerability(nvd_data)
        
        assert result["nvd_description"] == "Critical vulnerability in test component"
        assert result["nvd_cwe"] == ["CWE-79"]  # Should only include Primary type
        assert len(result["nvd_references"]) == 2
        assert result["full_cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
        assert result["cvss_score"] == 6.1

    def test_parse_nvd_vulnerability_minimal_data(self):
        """Test parsing of minimal NVD vulnerability data."""
        nvd_data = {}
        
        result = _parse_nvd_vulnerability(nvd_data)
        
        assert result["nvd_description"] == "No description available"
        assert result["nvd_cwe"] == []
        assert result["nvd_references"] == []
        assert result["full_cvss_vector"] is None
        assert result["cvss_score"] is None


class TestRateLimiter:
    """Test cases for rate limiter functionality."""

    def test_rate_limiter_basic_functionality(self):
        """Test basic rate limiter functionality."""
        rate_limiter = RateLimiter(max_workers=2, delay=1.0)
        
        # First call should not wait
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.1  # Should be immediate
        
        # Second call should not wait (within token limit)
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.1  # Should be immediate

    def test_rate_limiter_token_exhaustion(self):
        """Test rate limiter behavior when tokens are exhausted."""
        rate_limiter = RateLimiter(max_workers=1, delay=0.1)
        
        # First call should not wait
        rate_limiter.wait()
        
        # Second call should wait since tokens are exhausted
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time >= 0.09  # Should wait for token replenishment

    def test_rate_limiter_token_replenishment(self):
        """Test that tokens are replenished over time."""
        rate_limiter = RateLimiter(max_workers=2, delay=0.1)
        
        # Exhaust tokens
        rate_limiter.wait()
        rate_limiter.wait()
        
        # Wait for token replenishment
        time.sleep(0.11)
        
        # Should be able to make another call without delay
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.05  # Should be quick

    def test_rate_limiter_thread_safety(self):
        """Test rate limiter thread safety."""
        import threading
        
        rate_limiter = RateLimiter(max_workers=2, delay=0.1)
        results = []
        
        def worker():
            start_time = time.time()
            rate_limiter.wait()
            end_time = time.time()
            results.append(end_time - start_time)
        
        # Start multiple threads
        threads = [threading.Thread(target=worker) for _ in range(5)]
        for thread in threads:
            thread.start()
        for thread in threads:
            thread.join()
        
        # Some calls should be immediate, others should wait
        assert len(results) == 5
        immediate_calls = sum(1 for r in results if r < 0.05)
        delayed_calls = sum(1 for r in results if r >= 0.05)
        
        assert immediate_calls >= 2  # At least max_workers should be immediate
        assert delayed_calls >= 1   # At least one should be delayed 