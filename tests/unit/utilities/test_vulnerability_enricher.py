"""
Test suite for vulnerability enrichment utilities.

This module contains comprehensive tests for the vulnerability enricher functionality
including external API integration for EPSS scores, CISA KEV data, and NVD details.
"""

import pytest
import json
import time
import os
from unittest.mock import patch, Mock
from typing import Dict, List, Any

from workbench_cli.utilities.vulnerability_enricher import (
    enrich_vulnerabilities,
    _fetch_external_vulnerability_data,
    _fetch_epss_scores,
    _fetch_cisa_kev_data,
    _fetch_nvd_data,
    _fetch_single_cve_nvd,
    _parse_nvd_vulnerability,
    _fetch_alternative_vulnerability_data,
    _fetch_vulners_data,
    RateLimiter
)


class TestVulnerabilityEnricher:
    """Test cases for main vulnerability enrichment functionality."""

    def test_enrich_vulnerabilities_empty_list(self):
        """Test enrichment with empty CVE list."""
        result = enrich_vulnerabilities([])
        assert result == {}

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_external_vulnerability_data')
    def test_enrich_vulnerabilities_with_cves(self, mock_fetch):
        """Test enrichment with CVE list."""
        mock_fetch.return_value = {
            "CVE-2022-12345": {
                "epss_score": 0.85,
                "cisa_kev": True
            }
        }
        
        result = enrich_vulnerabilities(["CVE-2022-12345"])
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        mock_fetch.assert_called_once()

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_epss_scores')
    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_cisa_kev_data')
    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_nvd_data')
    def test_fetch_external_vulnerability_data_all_sources(self, mock_nvd, mock_kev, mock_epss):
        """Test fetching from all external data sources."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.return_value = {
            "CVE-2022-12345": {"epss_score": 0.85, "epss_percentile": 0.95}
        }
        mock_kev.return_value = ["CVE-2022-12345"]
        mock_nvd.return_value = {
            "CVE-2022-12345": {"nvd_description": "Test description"}
        }
        
        result = _fetch_external_vulnerability_data(cve_list)
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        assert result["CVE-2022-12345"]["cisa_kev"] == True
        assert result["CVE-2022-12345"]["nvd_description"] == "Test description"

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_epss_scores')
    def test_fetch_external_vulnerability_data_epss_only(self, mock_epss):
        """Test fetching EPSS data only."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.return_value = {
            "CVE-2022-12345": {"epss_score": 0.75}
        }
        
        result = _fetch_external_vulnerability_data(
            cve_list, 
            include_descriptions=False,
            include_epss=True,
            include_exploits=False
        )
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] == 0.75
        assert result["CVE-2022-12345"]["cisa_kev"] == False
        assert result["CVE-2022-12345"]["nvd_description"] is None

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_epss_scores')
    def test_fetch_external_vulnerability_data_with_exceptions(self, mock_epss):
        """Test handling of exceptions during external data fetching."""
        cve_list = ["CVE-2022-12345"]
        
        mock_epss.side_effect = Exception("EPSS API failed")
        
        # Should not raise exception, should return initialized data structure
        result = _fetch_external_vulnerability_data(cve_list)
        
        assert "CVE-2022-12345" in result
        assert result["CVE-2022-12345"]["epss_score"] is None
        assert result["CVE-2022-12345"]["cisa_kev"] == False


class TestEpssDataFetching:
    """Test cases for EPSS score fetching."""

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_epss_scores_success(self, mock_get):
        """Test successful EPSS score fetching."""
        mock_response = {
            "status": "OK",
            "data": [
                {
                    "cve": "CVE-2022-12345",
                    "epss": "0.85000",
                    "percentile": "0.95000"
                },
                {
                    "cve": "CVE-2022-67890",
                    "epss": "0.15000",
                    "percentile": "0.25000"
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_epss_scores(["CVE-2022-12345", "CVE-2022-67890"])
        
        assert len(result) == 2
        assert result["CVE-2022-12345"]["epss_score"] == 0.85
        assert result["CVE-2022-12345"]["epss_percentile"] == 0.95
        assert result["CVE-2022-67890"]["epss_score"] == 0.15

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_epss_scores_batch_processing(self, mock_get):
        """Test EPSS batch processing with large CVE lists."""
        # Create a list larger than batch size (100)
        cve_list = [f"CVE-2022-{i:05d}" for i in range(150)]
        
        # Mock responses for two batches
        mock_response = {
            "status": "OK",
            "data": [{"cve": cve, "epss": "0.5", "percentile": "0.5"} for cve in cve_list[:100]]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        with patch('workbench_cli.utilities.vulnerability_enricher.time.sleep'):
            result = _fetch_epss_scores(cve_list)
        
        # Should be called twice for two batches
        assert mock_get.call_count == 2
        assert len(result) == 100  # Only first batch in mock response

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_epss_scores_api_error(self, mock_get):
        """Test handling of EPSS API errors."""
        mock_get.side_effect = Exception("API Error")
        
        result = _fetch_epss_scores(["CVE-2022-12345"])
        
        assert result == {}

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_epss_scores_invalid_response(self, mock_get):
        """Test handling of invalid EPSS API response."""
        mock_response = {"status": "ERROR", "message": "Invalid request"}
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_epss_scores(["CVE-2022-12345"])
        
        assert result == {}


class TestCisaKevDataFetching:
    """Test cases for CISA KEV data fetching."""

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_cisa_kev_data_success(self, mock_get):
        """Test successful CISA KEV data fetching."""
        mock_response = {
            "vulnerabilities": [
                {
                    "cveID": "CVE-2022-12345",
                    "vendorProject": "Test Vendor",
                    "product": "Test Product"
                },
                {
                    "cveID": "CVE-2022-67890",
                    "vendorProject": "Another Vendor",
                    "product": "Another Product"
                }
            ]
        }
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345", "CVE-2022-99999"])
        
        assert len(result) == 1
        assert "CVE-2022-12345" in result
        assert "CVE-2022-99999" not in result

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_cisa_kev_data_no_vulnerabilities(self, mock_get):
        """Test CISA KEV response with no vulnerabilities section."""
        mock_response = {"other_data": "value"}
        mock_get.return_value.json.return_value = mock_response
        mock_get.return_value.raise_for_status.return_value = None
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345"])
        
        assert result == []

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_cisa_kev_data_api_error(self, mock_get):
        """Test handling of CISA KEV API errors."""
        mock_get.side_effect = Exception("API Error")
        
        result = _fetch_cisa_kev_data(["CVE-2022-12345"])
        
        assert result == []


class TestNvdDataFetching:
    """Test cases for NVD data fetching."""

    def test_fetch_nvd_data_caching(self):
        """Test that fetch_nvd_data uses module-level caching."""
        # Clear any existing cache
        from workbench_cli.utilities.vulnerability_enricher import _NVD_CACHE
        _NVD_CACHE.clear()
        
        # First call should fetch data
        with patch('workbench_cli.utilities.vulnerability_enricher._fetch_single_cve_nvd') as mock_fetch:
            mock_fetch.return_value = {"nvd_description": "Test description"}
            
            result1 = _fetch_nvd_data(["CVE-2022-12345"])
            
            # Second call should use cache
            result2 = _fetch_nvd_data(["CVE-2022-12345"])
            
            # Should have fetched only once
            assert mock_fetch.call_count == 1
            assert result1 == result2

    @patch.dict(os.environ, {"NVD_API_KEY": "test-key"})
    @patch('workbench_cli.utilities.vulnerability_enricher.ThreadPoolExecutor')
    def test_fetch_nvd_data_with_api_key(self, mock_executor):
        """Test NVD data fetching with API key."""
        # Clear cache to ensure fresh fetch
        from workbench_cli.utilities.vulnerability_enricher import _NVD_CACHE
        _NVD_CACHE.clear()
        
        # Mock the executor and its methods
        mock_executor_instance = mock_executor.return_value.__enter__.return_value
        mock_future = mock_executor_instance.submit.return_value
        mock_future.result.return_value = {
            "nvd_description": "Test description",
            "nvd_cwe": ["CWE-79"]
        }
        
        from concurrent.futures import as_completed
        with patch('workbench_cli.utilities.vulnerability_enricher.as_completed') as mock_as_completed:
            mock_as_completed.return_value = [mock_future]
            
            result = _fetch_nvd_data(["CVE-2022-12345"])
            
            assert "CVE-2022-12345" in result
            # Verify executor was called with higher max_workers for API key
            mock_executor.assert_called_once_with(max_workers=5)

    @patch.dict(os.environ, {}, clear=True)
    @patch('workbench_cli.utilities.vulnerability_enricher.ThreadPoolExecutor')
    def test_fetch_nvd_data_without_api_key(self, mock_executor):
        """Test NVD data fetching without API key."""
        # Clear cache to ensure fresh fetch
        from workbench_cli.utilities.vulnerability_enricher import _NVD_CACHE
        _NVD_CACHE.clear()
        
        # Mock the executor
        mock_executor_instance = mock_executor.return_value.__enter__.return_value
        mock_future = mock_executor_instance.submit.return_value
        mock_future.result.return_value = {
            "nvd_description": "Test description"
        }
        
        from concurrent.futures import as_completed
        with patch('workbench_cli.utilities.vulnerability_enricher.as_completed') as mock_as_completed:
            mock_as_completed.return_value = [mock_future]
            
            result = _fetch_nvd_data(["CVE-2022-12345"])
            
            assert "CVE-2022-12345" in result
            # Verify executor was called with lower max_workers for no API key
            mock_executor.assert_called_once_with(max_workers=2)

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_single_cve_nvd_success(self, mock_get):
        """Test successful fetching of a single CVE from NVD."""
        mock_response = {
            "vulnerabilities": [{
                "cve": {
                    "descriptions": [{"lang": "en", "value": "Test vulnerability description"}],
                    "weaknesses": [{
                        "type": "Primary",
                        "description": [{"lang": "en", "value": "CWE-79"}]
                    }],
                    "references": [
                        {"url": "https://example.com/ref1", "source": "test-source", "tags": ["Vendor Advisory"]}
                    ],
                    "metrics": {
                        "cvssMetricV31": [{
                            "cvssData": {
                                "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                                "baseScore": 6.1
                            }
                        }]
                    }
                }
            }]
        }
        mock_get.return_value.status_code = 200
        mock_get.return_value.json.return_value = mock_response
        
        rate_limiter = RateLimiter(2, 1.0)
        result = _fetch_single_cve_nvd("CVE-2022-12345", None, rate_limiter, 30)
        
        assert result is not None
        assert result["nvd_description"] == "Test vulnerability description"
        assert result["nvd_cwe"] == ["CWE-79"]
        assert len(result["nvd_references"]) == 1
        assert result["full_cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
        assert result["cvss_score"] == 6.1

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_single_cve_nvd_rate_limited(self, mock_get):
        """Test handling of rate limiting when fetching CVE data."""
        # Create separate mock responses
        rate_limited_response = Mock()
        rate_limited_response.status_code = 429
        rate_limited_response.headers = {'Retry-After': '1'}
        
        success_response = Mock()
        success_response.status_code = 200
        success_response.json.return_value = {
            "vulnerabilities": [{
                "cve": {
                    "descriptions": [{"lang": "en", "value": "Test description"}],
                    "weaknesses": [],
                    "references": [],
                    "metrics": {}
                }
            }]
        }
        
        # Configure mock to return rate limited response first, then success
        mock_get.side_effect = [rate_limited_response, success_response]
        
        rate_limiter = RateLimiter(2, 1.0)
        
        with patch('workbench_cli.utilities.vulnerability_enricher.time.sleep') as mock_sleep:
            result = _fetch_single_cve_nvd("CVE-2022-12345", None, rate_limiter, 30)
            
            assert result is not None
            assert result["nvd_description"] == "Test description"
            mock_sleep.assert_called_once_with(1)  # Should wait for retry-after

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.get')
    def test_fetch_single_cve_nvd_with_api_key(self, mock_get):
        """Test fetching CVE data with API key."""
        mock_response = {
            "vulnerabilities": [{
                "cve": {
                    "descriptions": [{"lang": "en", "value": "Test description"}],
                    "weaknesses": [],
                    "references": [],
                    "metrics": {}
                }
            }]
        }
        mock_get.return_value.status_code = 200
        mock_get.return_value.json.return_value = mock_response
        
        rate_limiter = RateLimiter(5, 0.6)
        result = _fetch_single_cve_nvd("CVE-2022-12345", "test-api-key", rate_limiter, 30)
        
        assert result is not None
        # Verify API key was included in headers
        call_args = mock_get.call_args
        assert "apiKey" in call_args[1]["headers"]
        assert call_args[1]["headers"]["apiKey"] == "test-api-key"

    def test_parse_nvd_vulnerability_complete_data(self):
        """Test parsing of complete NVD vulnerability data."""
        nvd_data = {
            "descriptions": [
                {"lang": "en", "value": "Critical vulnerability in test component"}
            ],
            "weaknesses": [
                {
                    "type": "Primary",
                    "description": [{"lang": "en", "value": "CWE-79"}]
                },
                {
                    "type": "Secondary",
                    "description": [{"lang": "en", "value": "CWE-20"}]
                }
            ],
            "references": [
                {"url": "https://example.com/ref1", "source": "vendor", "tags": ["Vendor Advisory"]},
                {"url": "https://example.com/ref2", "source": "mitre", "tags": ["Third Party Advisory"]}
            ],
            "metrics": {
                "cvssMetricV31": [{
                    "cvssData": {
                        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                        "baseScore": 6.1
                    }
                }]
            }
        }
        
        result = _parse_nvd_vulnerability(nvd_data)
        
        assert result["nvd_description"] == "Critical vulnerability in test component"
        assert result["nvd_cwe"] == ["CWE-79"]  # Should only include Primary type
        assert len(result["nvd_references"]) == 2
        assert result["full_cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
        assert result["cvss_score"] == 6.1

    def test_parse_nvd_vulnerability_minimal_data(self):
        """Test parsing of minimal NVD vulnerability data."""
        nvd_data = {}
        
        result = _parse_nvd_vulnerability(nvd_data)
        
        assert result["nvd_description"] == "No description available"
        assert result["nvd_cwe"] == []
        assert result["nvd_references"] == []
        assert result["full_cvss_vector"] is None
        assert result["cvss_score"] is None


class TestAlternativeDataSources:
    """Test cases for alternative vulnerability data sources."""

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_vulners_data')
    def test_fetch_alternative_vulnerability_data_vulners_success(self, mock_vulners):
        """Test successful fetching from Vulners API."""
        mock_vulners.return_value = {
            "nvd_description": "Description from Vulners",
            "source": "vulners"
        }
        
        result = _fetch_alternative_vulnerability_data("CVE-2022-12345")
        
        assert result["nvd_description"] == "Description from Vulners"
        assert result["source"] == "vulners"

    @patch('workbench_cli.utilities.vulnerability_enricher._fetch_vulners_data')
    def test_fetch_alternative_vulnerability_data_vulners_failure(self, mock_vulners):
        """Test handling of Vulners API failure."""
        mock_vulners.side_effect = Exception("Vulners API failed")
        
        result = _fetch_alternative_vulnerability_data("CVE-2022-12345")
        
        assert result is None

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.post')
    def test_fetch_vulners_data_success(self, mock_post):
        """Test successful fetching of data from Vulners API."""
        mock_response = {
            "result": "OK",
            "data": {
                "documents": [{
                    "description": "Vulnerability description from Vulners",
                    "cwe": ["CWE-79", "CWE-20"],
                    "references": [
                        "https://vulners.com/cve/CVE-2022-12345",
                        "https://example.com/vuln-info"
                    ],
                    "cvss": {
                        "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                        "score": 6.1
                    }
                }]
            }
        }
        mock_post.return_value.status_code = 200
        mock_post.return_value.json.return_value = mock_response
        
        result = _fetch_vulners_data("CVE-2022-12345")
        
        assert result is not None
        assert result["nvd_description"] == "Vulnerability description from Vulners"
        assert result["nvd_cwe"] == ["CWE-79", "CWE-20"]
        assert len(result["nvd_references"]) == 2
        assert result["full_cvss_vector"] == "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"
        assert result["cvss_score"] == 6.1
        assert result["source"] == "vulners"

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.post')
    def test_fetch_vulners_data_failure(self, mock_post):
        """Test handling of Vulners API failures."""
        mock_post.return_value.status_code = 500
        
        result = _fetch_vulners_data("CVE-2022-12345")
        
        assert result is None

    @patch('workbench_cli.utilities.vulnerability_enricher.requests.post')
    def test_fetch_vulners_data_invalid_response(self, mock_post):
        """Test handling of invalid Vulners API response."""
        mock_response = {"result": "ERROR", "message": "Invalid CVE"}
        mock_post.return_value.status_code = 200
        mock_post.return_value.json.return_value = mock_response
        
        result = _fetch_vulners_data("CVE-2022-12345")
        
        assert result is None


class TestRateLimiter:
    """Test cases for rate limiter functionality."""

    def test_rate_limiter_basic_functionality(self):
        """Test basic rate limiter functionality."""
        rate_limiter = RateLimiter(max_workers=2, delay=1.0)
        
        # First call should not wait
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.1  # Should be immediate
        
        # Second call should not wait (within token limit)
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.1  # Should be immediate

    def test_rate_limiter_token_exhaustion(self):
        """Test rate limiter behavior when tokens are exhausted."""
        rate_limiter = RateLimiter(max_workers=1, delay=0.1)
        
        # First call should not wait
        rate_limiter.wait()
        
        # Second call should wait since tokens are exhausted
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time >= 0.09  # Should wait for token replenishment

    def test_rate_limiter_token_replenishment(self):
        """Test that tokens are replenished over time."""
        rate_limiter = RateLimiter(max_workers=2, delay=0.1)
        
        # Exhaust tokens
        rate_limiter.wait()
        rate_limiter.wait()
        
        # Wait for token replenishment
        time.sleep(0.11)
        
        # Should be able to make another call without delay
        start_time = time.time()
        rate_limiter.wait()
        end_time = time.time()
        
        assert end_time - start_time < 0.05  # Should be quick

    def test_rate_limiter_thread_safety(self):
        """Test rate limiter thread safety."""
        import threading
        
        rate_limiter = RateLimiter(max_workers=2, delay=0.1)
        results = []
        
        def worker():
            start_time = time.time()
            rate_limiter.wait()
            end_time = time.time()
            results.append(end_time - start_time)
        
        # Start multiple threads
        threads = [threading.Thread(target=worker) for _ in range(5)]
        for thread in threads:
            thread.start()
        for thread in threads:
            thread.join()
        
        # Some calls should be immediate, others should wait
        assert len(results) == 5
        immediate_calls = sum(1 for r in results if r < 0.05)
        delayed_calls = sum(1 for r in results if r >= 0.05)
        
        assert immediate_calls >= 2  # At least max_workers should be immediate
        assert delayed_calls >= 1   # At least one should be delayed 